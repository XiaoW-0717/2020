# 报错集合

[TOC]





## 1、运行`npm run server`，报错如下

```
Error from chokidar (C:\): Error: EBUSY: resource busy or locked, lstat 'C:\hiberfil.sys'
Error from chokidar (C:\): Error: EBUSY: resource busy or locked, lstat 'C:\pagefile.sys'
Error from chokidar (C:\): Error: EBUSY: resource busy or locked, lstat 'C:\swapfile.sys'
```

## 2、npm 报错This is probably not a problem with npm. There is likely additional logging output above.

- 上述两种问题都可以用如下方法解决：

```
#1、删除 node_modules、package-lock.json

#2、清理缓存
npm cache clean --force

#3、重新安装
npm i

#4、重新运行就OK了
```

## 3、Django post请求403 (Forbidden)

axios post请求跨域403以及传参问题

```
Forbidden (CSRF cookie not set.)
```

![](IMG/微信截图_20200916182527.png)



- 刚开始以为是POST发送请求传输JSON数据格式导致的问题，

  - 注：浏览器跨域并不支持application/json的Content-Type，即使后台设置了允许的跨域头部参数，依然会报错。

    参考：https://blog.csdn.net/weixin_41829196/article/details/85986331

- 后来确认没问题，发现是Django在处理post请求时多次出现403错误。

  - 解决方法一

    - 简单暴力，注释掉`setting.py`中的csrf拦截

    - 缺点：导致Django项目完全无法防止csrf攻击。（我采用了这种方法）

      ![](IMG/微信截图_20200917082546.png)

    

  - 解决方法二

    - 在 `views.py`文件中，使用@csrf_exempt装饰器，避开CsrfViewMiddleware的检测

    - 缺点：导致此次请求无法防止csrf攻击，但是比第一种好很多。

      ```python
      #导入,可以使此次请求忽略csrf校验
      from django.views.decorators.csrf import csrf_exempt
      
      #在处理函数加此装饰器即可
      @csrf_exempt
      def post(request):
           name=request.post['name']
           return HttpResponse('welcome!{}'.format(name))
      ```

      

  - 解决方法三

    - 对使用模版进行开发的MTV模式,在模版文件提交form表单代码中添加csrf **{% csrf_token %}**

      ```html
      <body>
          <h1>尚未登录，请登录：</h1>
          <form action="" method="POST">
              {% csrf_token %}
              用户名：<input type="text" name="username" /><br />
              密码：<input type="password" name="password" /><br />
              <input type="submit" value="登录" name="login"/>
              <a href="/reg/">注册</a>
          </form>
      </body>
      
      ```

      

  - 解决方法四

    - django的csrf安全工作顺序是：先从后台获取csrf_token 并发送给前端，然后前端在进行form表单提交时，把带有名为csrfmiddlewaretoken，值为 csrf_token 的字段一起发送给后端进行校验。
    - 此解决方案便是按照此逻辑，先通过一个接口获取 csrf_token，然后在form表单中一起提交给后端校验

    ```python
    from django.template.context_processors import csrf
    
    def get_csrf(request):
            #生成 csrf 数据，发送给前端
        x = csrf(request)
        csrf_token = x['csrf_token']
        return HttpResponse('{} ; {}'.format(str(re), csrf_token))
    
    ```

    

  - 参考

    - [参考一](https://blog.csdn.net/u010098760/article/details/100920946?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight)
    - [参考二](https://blog.csdn.net/weixin_34050519/article/details/93235772?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight)

    


## 4、axios 使用post方式传递参数，后端接受不到

- params是添加到url的请求字符串中的，用于get请求。
- data是添加到请求体（body）中的， 用于post请求。
- `get`请求是发送参数，在`params`中定义。而`POST`请求是发送`request body`,需要在`data`中定义
- 解决，引入qs

```
import qs from "qs";
```

```
let postData = qs.stringify({
        "username":this.Register.username,
        "email":this.Register.email,
        "password":this.Register.password,
        "mobile":this.Register.mobile,
        "smscode":this.Register.smscode,
      })
```

```
 const url = `http://127.0.0.1:8000/api/register/`;
 axios
 .post(
 url,
 {
 // params: userInfo,
 data: postData
 },
 {
 headers: { "Content-Type": "application/x-www-form-urlencoded" }
 }
 )
 .then(res => {

});
```

- 这里又遇到一个很奇怪的问题，就是第一个参数传过去是None。我额外添加了一个参数，用来解决None，以后发现根本再来补充。

```
 let postData = qs.stringify({
        first: 1, //用于解决第一个参数为None设置的无用参数，现在我还不知道为什么，但这样可以解决，以后发现根本再来补充
        username: this.Register.username,
        email: this.Register.email,
        password: this.Register.password,
        mobile: this.Register.mobile,
        smscode: this.Register.smscode
      });
```



- 参考：https://segmentfault.com/a/1190000012635783









## 5、element_ui 表单验证 this.$refs[formName].validate()里面的内容不执行

- 在自定义验证里面每一个判断都要有callback(),就是要保证最后执行到的是callback()

参考：

https://segmentfault.com/q/1010000009679079





400	

403

405