# 地震数据解析页面

[TOC]

##  前言 

- 将`SEGY`数据写入服务器，进行今解析

- `SeismicAnalysi.vue`
- `SeismicFileRead`





## 1. 后端

### 1.1 服务器文件表格展示

- 将服务器中文件返回前端表格展示

- `views.py`

  ```python
  # 地震数据解析，获取文件
  @require_http_methods(['GET'])
  def SeismicFileRead(request):
  
      # base_dir = 'c:/'
      base_dir = "././pic/"
      list = os.listdir(base_dir)
  
      filelist = []
      for i in range(0, len(list)):
          path = os.path.join(base_dir, list[i])
          if os.path.isfile(path):
              filelist.append(list[i])
      list_db = []
      content = {}
      for i in range(0, len(filelist)):
          path = os.path.join(base_dir, filelist[i])
          if os.path.isdir(path):
              continue
          # 获取文件的修改时间
          timestamp = os.path.getmtime(path)
          # print(timestamp)
          # 获取文件的修改时间
          # ts1 = os.stat(path).st_mtime
          # print(ts1)
          # 获取文件的大小,结果保留两位小数，单位为MB
          filesize = os.path.getsize(path)
          fsize = filesize/float(1024*1024)
          size = round(fsize, 2)
          filesize = str(size) + 'MB'
          # print(size)
  
          date = datetime.datetime.fromtimestamp(timestamp)
          upload_time = date.strftime('%Y-%m-%d %H:%M:%S')
          # upload_time = date.strftime('%Y-%m-%d')
          # print(list[i], ' 最近修改时间是: ', date.strftime('%Y-%m-%d %H:%M:%S'))
  
          fileinfo = {
              'filename': list[i],
              'filesize': filesize,
              'upload_time': upload_time,
          }
          # print(type(fileinfo))
          # json_str = str(fileinfo)
          # print(type(json_str))
          list_db.append(fileinfo)
          content = json.dumps(list_db)    #这个地方要用字符串传到前端去
      print(content)
      print(type(content))
      return HttpResponse(content, "application/json")
  ```

  

### 1.2 服务器文件删除

- `views.py`

  ```python
  # 地震数据解析，删除服务器文件
  @require_http_methods(['POST'])
  def SeismicAnalysisDelete(request):
      # filename1 = request.POST
      # print(filename1)
      filename = request.POST.get('filename')
      print(filename)
      content = "..\mongeostore_env\pic\\" + filename
      os.remove(content)
      return HttpResponse('success')
  ```

  

### 1.3 解析数据

- `views.py`

  ```python
  # 地震数据解析，获取服务器文件
  @require_http_methods(['GET'])
  def SeismicFileRead(request):
  
      # base_dir = 'c:/'
      base_dir = "././pic/"
      list = os.listdir(base_dir)
  
      filelist = []
      for i in range(0, len(list)):
          path = os.path.join(base_dir, list[i])
          if os.path.isfile(path):
              filelist.append(list[i])
      list_db = []
      content = {}
      for i in range(0, len(filelist)):
          path = os.path.join(base_dir, filelist[i])
          if os.path.isdir(path):
              continue
          # 获取文件的修改时间
          timestamp = os.path.getmtime(path)
          # print(timestamp)
          # 获取文件的修改时间
          # ts1 = os.stat(path).st_mtime
          # print(ts1)
          # 获取文件的大小,结果保留两位小数，单位为MB
          filesize = os.path.getsize(path)
          fsize = filesize/float(1024*1024)
          size = round(fsize, 2)
          filesize = str(size) + 'MB'
          # print(size)
  
          date = datetime.datetime.fromtimestamp(timestamp)
          upload_time = date.strftime('%Y-%m-%d %H:%M:%S')
          # upload_time = date.strftime('%Y-%m-%d')
          # print(list[i], ' 最近修改时间是: ', date.strftime('%Y-%m-%d %H:%M:%S'))
  
          fileinfo = {
              'filename': list[i],
              'filesize': filesize,
              'upload_time': upload_time,
          }
          # print(type(fileinfo))
          # json_str = str(fileinfo)
          # print(type(json_str))
          list_db.append(fileinfo)
          content = json.dumps(list_db)  # 这个地方要用字符串传到前端去
      # print(content)
      # print(type(content))
      return HttpResponse(content, "application/json")
  
  
  # 地震数据解析，获取服务器文件
  @require_http_methods(['GET'])
  def SeismicHeaderQuery(request):
      print(request.GET)
      filename = request.GET.get('filename')
      filequery = request.GET.get('queryparams')
      # print(filename)
      content = "..\mongeostore_env\pic\\" + filename
  
      try:
          with segyio.open(content, mode="r", strict=False, ignore_geometry=False, endian='big') as f:
              if filequery == 'header':
                  datatest = f.header[0]
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
              elif filequery == 'Bin':
                  datatest = f.bin
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
              elif filequery == 'track':
                  datatest = f.text
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
              elif filequery == 'traces':
                  datatest = f.trace
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
              elif filequery == 'trace1':
                  datatest = f.trace[0]  # 拿到segy中数据
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
              elif filequery == 'trace_1':
                  datatest = f.trace[-1]
  
                  # print(str(datatest))
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
              else:
                  datatest = f.trace[int(filequery)]
                  # print(filequery)
                  # print(type(filequery))
                  # print(datatest)
                  queryinfo = str(datatest)
                  return HttpResponse(queryinfo)
      except:
          print('解析错误')
          return HttpResponse('err')
  ```



### 1.4 上传数据

- `views.py`

  ```python
  # 地震数据解析，本地文件上传服务器
  class SeismicAnalysisUpload(APIView):
      def get(self, request, *args, **kwargs):
          """
          docstring
          """
          # print("走的是GET方法")
          response = {}
          response['code'] = 200
          # response["Access-Control-Allow-Methods"] = "POST"
          return HttpResponse(json.dumps(response), content_type="application/json")
  
      def post(self, request):
          File = request.FILES.get("file", None)
          # filename = request.POST.get('filename')
          # 保存到本地
          if not os.path.exists('pic/'):
              os.mkdir('pic/')
          with open("./pic/%s" % File.name, 'wb+') as f:
              for chunk in File.chunks():
                  f.write(chunk)
              f.close()
          return HttpResponse('success')
  ```

  

### 1.5 云端数据

- 这部分在使用进度条时，想使用前端定时器的方式，但后端获取实时下载百分比返回给前端，交互比较不理性；故而采用后端使用`WebSocket`通信；完成这部分先看下一节；

- `views.py`

  ```python
  # 地震数据解析，下载云端数据
  # @require_http_methods(['GET'])
  @accept_websocket
  def AnalysisCloudDown(request):
  
      if request.is_websocket():  # 如果请求是websocket请求：
  
          WebSocket = request.websocket
          print(WebSocket)
          i = 0  # 设置发送至前端的次数
          messages = {}
  
          while True:
              i += 1  # 递增次数 i
              time.sleep(1)  # 休眠1秒
  
              # 判断是否通过websocket接收到数据
              if WebSocket.has_messages():
  
                  # 存在Websocket客户端发送过来的消息
                  client_msg = WebSocket.read().decode()
                  print(client_msg)
                  # # 从数据库拿到数据
                  seismic_obj = SeismicInfo.objects(id=client_msg).first()
                  filename = seismic_obj.seismic_filename
                  seismic_file = seismic_obj.filedata.read  # 注意这个地方不用加（）
                  seismic_filensize = seismic_obj.filedata.length
                  content_type = seismic_obj.filedata.content_type
                  filename = filename + '.' + content_type
                  # 数据写入服务器
                  RECORD_SIZE = 1024*40  # 单位是B
                  with open("../mongeostore_env/pic/%s" % filename, 'wb') as f:
                      # f.write(seismic_file)
                      # print(f.tell())
                      # print('save success')
                      records = iter(partial(seismic_file, RECORD_SIZE), b'')
                      for r in records:
                          f.write(r)
                          percent = int(f.tell()*100/seismic_filensize)
                          # print(percent)
                          # print(percent)
                          # print(f.tell())
                          # return HttpResponse(percent)
  
                          # 设置发送前端的数据
                          messages = {
                              # 'time': time.strftime('%Y.%m.%d %H:%M:%S', time.localtime(time.time())),
                              # 'server_msg': 'send %d times!' % i,
                              'client_msg': client_msg,
                              'percent': percent
                          }
                          request.websocket.send(json.dumps(messages))
              # else:
              #     # 设置发送前端的数据
              #     messages = {
              #         'time': time.strftime('%Y.%m.%d %H:%M:%S', time.localtime(time.time())),
              #         'server_msg': 'send %d times!' % i,
              #     }
  
              #     # 设置发送数据为json格式
              #     request.websocket.send(json.dumps(messages))
      else:
          try:#如果是普通的http方法
              message = request.GET['message']
              return HttpResponse(message)
          except:
              # return render(request,'index.html')
              return HttpResponse('test123')
  
  ```

  - [进度条](https://blog.csdn.net/WDCCSDN/article/details/89395287)
  - [Django进度条](https://blog.csdn.net/chaoren499/article/details/97135142)
  - [python](https://www.jianshu.com/p/b0a07bd72fb8)

- 这里涉及到进度条更新问题，看了相关文章，决定尝试采用`dwebsocket`



## 2. 前端

- `SeismicAnalysi.vue`

  ```
  
  ```

  

- `UploadFile.vue`

  ```
  
  ```

  